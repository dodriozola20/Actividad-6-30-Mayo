# -*- coding: utf-8 -*-
"""TAREA DANIEL ODR

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O8v1exVRErB8kY2BYKLVCqZFDqq64r_W
"""

# Commented out IPython magic to ensure Python compatibility.
# Importar librerías requeridas
import pandas as pd
import numpy as np
from google.colab import files
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, kpss
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.vector_ar.vecm import coint_johansen
import matplotlib.pyplot as plt
import warnings

# Asegurar que las gráficas se muestren en Colab
# %matplotlib inline

# Suprimir advertencias específicas para mantener la salida limpia
warnings.filterwarnings("ignore", category=UserWarning, message="Non-stationary starting autoregressive parameters")
warnings.filterwarnings("ignore", category=UserWarning, message="Non-invertible starting MA parameters")
warnings.filterwarnings("ignore", category=sm.tools.sm_exceptions.InterpolationWarning)

# Función para pruebas de estacionariedad con interpretación
def unit_root_tests(series, name):
    series = series.dropna()
    if len(series) < 10:
        print(f"Error: Datos insuficientes para {name} después de eliminar NaN")
        return False
    print(f"\nPruebas de Estacionariedad para {name}:")

    # Prueba ADF
    adf_result = adfuller(series)
    print("Prueba ADF:")
    print(f'Estadístico ADF: {adf_result[0]:.4f}')
    print(f'p-valor: {adf_result[1]:.4f}')
    print(f'Valores Críticos: {adf_result[4]}')
    print("Interpretación:")
    if adf_result[1] < 0.05:
        print(f"  - p-valor < 0.05: Rechazar hipótesis nula - {name} es estacionaria")
    else:
        print(f"  - p-valor >= 0.05: No se rechaza la hipótesis nula - {name} puede ser no estacionaria")

    # Prueba KPSS
    try:
        kpss_result = kpss(series, regression='c')
        print("\nPrueba KPSS:")
        print(f'Estadístico KPSS: {kpss_result[0]:.4f}')
        print(f'p-valor: {kpss_result[1]:.4f}')
        print(f'Valores Críticos: {kpss_result[3]}')
        print("Interpretación:")
        if kpss_result[1] < 0.05:
            print(f"  - p-valor < 0.05: Rechazar hipótesis nula - {name} es no estacionaria")
        else:
            print(f"  - p-valor >= 0.05: No se rechaza la hipótesis nula - {name} puede ser estacionaria")
    except Exception as e:
        print(f"\nPrueba KPSS: Falló para {name} ({e})")
        return False
    return adf_result[1] < 0.05 and kpss_result[1] >= 0.05

# Función para prueba de cointegración con interpretación
def cointegration_test(df, interval):
    df = df.dropna()
    if df.empty or len(df) < 10:
        print(f"Error: No hay datos válidos para la prueba de cointegración ({interval})")
        return False
    try:
        result = coint_johansen(df, det_order=0, k_ar_diff=1)
        print(f"\nPrueba de Cointegración Johansen ({interval}):")
        print(f"Estadístico de traza: {result.lr1}")
        print(f"Valores críticos (90%, 95%, 99%): {result.cvt}")
        print("Interpretación:")
        for i in range(len(result.lr1)):
            if result.lr1[i] > result.cvt[i, 1]:
                print(f"  - r = {i}: Existe cointegración al 95% de confianza")
                print(f"    Estadístico de traza ({result.lr1[i]:.2f}) > Valor crítico al 95% ({result.cvt[i, 1]:.2f})")
            else:
                print(f"  - r = {i}: No hay cointegración al 95% de confianza")
                print(f"    Estadístico de traza ({result.lr1[i]:.2f}) <= Valor crítico al 95% ({result.cvt[i, 1]:.2f})")
        if result.lr1[0] > result.cvt[0, 1]:
            print("Conclusión: TSLA, AAPL y META están cointegradas - comparten una relación de equilibrio a largo plazo")
            return True
        else:
            print("Conclusión: No hay evidencia de cointegración entre TSLA, AAPL y META")
            return False
    except Exception as e:
        print(f"Error: Falló la prueba de cointegración para {interval} ({e})")
        return False

# Función para encontrar el mejor modelo ARIMA con interpretación
def find_best_arima(series, name, max_p=3, max_d=2, max_q=3):
    series = series.dropna()
    if len(series) < 10:
        print(f"Error: No hay datos válidos para {name} para el modelo ARIMA")
        return (0, 0, 0)
    best_aic = float('inf')
    best_order = (0, 0, 0)

    for p in range(max_p + 1):
        for d in range(max_d + 1):
            for q in range(max_q + 1):
                try:
                    model = ARIMA(series, order=(p, d, q))
                    results = model.fit(method='nm')  # Método robusto
                    if results.aic < best_aic:
                        best_aic = results.aic
                        best_order = (p, d, q)
                except:
                    continue

    print(f"\nMejor modelo ARIMA para {name}:")
    print(f"Orden: {best_order}")
    print(f"AIC: {best_aic:.2f}")
    print("Interpretación:")
    print(f"  - p={best_order[0]}: {best_order[0]} término(s) autorregresivo(s)")
    print(f"  - d={best_order[1]}: {best_order[1]} diferencia(s) necesaria(s) para estacionariedad")
    print(f"  - q={best_order[2]}: {best_order[2]} término(s) de media móvil")
    return best_order

# Función para graficar pronósticos con intervalos de confianza e interpretación
def plot_forecast(model, series, name, interval, steps=30):
    print(f"Generando gráfica de pronóstico para {name} ({interval})...")
    forecast_obj = model.get_forecast(steps=steps)
    forecast = forecast_obj.predicted_mean
    conf_int = forecast_obj.conf_int()

    forecast_index = range(len(series), len(series) + steps)

    plt.figure(figsize=(12, 6))
    plt.plot(series, label=f'{name} Histórico ({interval})')
    plt.plot(forecast_index, forecast, label='Pronóstico', color='red')
    plt.fill_between(forecast_index,
                     conf_int.iloc[:, 0],
                     conf_int.iloc[:, 1],
                     color='pink',
                     alpha=0.3,
                     label='Intervalo de Confianza al 95%')
    plt.title(f'Pronóstico de Precios de {name} ({interval})')
    plt.xlabel('Índice de Tiempo')
    plt.ylabel('Precio (USD)')
    plt.legend()
    plt.show()
    print(f"Gráfica de pronóstico para {name} ({interval}) generada.")

    # Interpretación del pronóstico
    last_value = series.iloc[-1]
    mean_forecast = forecast.mean()
    print(f"\nInterpretación del Pronóstico para {name} ({interval}):")
    print(f"Último valor observado: {last_value:.2f}")
    print(f"Valor promedio del pronóstico: {mean_forecast:.2f}")
    print(f"Cambio en el pronóstico: {mean_forecast - last_value:.2f}")
    if mean_forecast > last_value:
        print("Tendencia: Pronóstico con tendencia alcista")
    elif mean_forecast < last_value:
        print("Tendencia: Pronóstico con tendencia bajista")
    else:
        print("Tendencia: Pronóstico estable")
    print(f"Rango del intervalo de confianza al 95% en el período {steps}: [{conf_int.iloc[-1, 0]:.2f}, {conf_int.iloc[-1, 1]:.2f}]")

# Procesar datos para 1min y 3min
intervals = ['1min', '3min']
for interval in intervals:
    print(f"\n=== Procesando datos de {interval} ===")

    # Subir archivos Excel
    try:
        print(f"Sube el archivo TSLA_{interval}.xlsx")
        tsla_upload = files.upload()
        tsla_filename = list(tsla_upload.keys())[0]
        tsla_df = pd.read_excel(tsla_filename)
    except Exception as e:
        print(f"Error al subir TSLA_{interval}.xlsx: {e}")
        continue

    try:
        print(f"Sube el archivo AAPL_{interval}.xlsx")
        aapl_upload = files.upload()
        aapl_filename = list(aapl_upload.keys())[0]
        aapl_df = pd.read_excel(aapl_filename)
    except Exception as e:
        print(f"Error al subir AAPL_{interval}.xlsx: {e}")
        continue

    try:
        print(f"Sube el archivo META_{interval}.xlsx")
        meta_upload = files.upload()
        meta_filename = list(meta_upload.keys())[0]
        meta_df = pd.read_excel(meta_filename)
    except Exception as e:
        print(f"Error al subir META_{interval}.xlsx: {e}")
        continue

    # Mostrar columnas
    print("\nColumnas de TSLA:", list(tsla_df.columns))
    print("\nColumnas de AAPL:", list(aapl_df.columns))
    print("\nColumnas de META:", list(meta_df.columns))

    # Preguntar por los nombres de las columnas
    print(f"Columnas disponibles para TSLA ({interval}): {list(tsla_df.columns)}")
    tsla_close_column = input(f"Ingresa el nombre de la columna de precios de cierre para TSLA ({interval}): ").strip()
    print(f"Columnas disponibles para AAPL ({interval}): {list(aapl_df.columns)}")
    aapl_close_column = input(f"Ingresa el nombre de la columna de precios de cierre para AAPL ({interval}): ").strip()
    print(f"Columnas disponibles para META ({interval}): {list(meta_df.columns)}")
    meta_close_column = input(f"Ingresa el nombre de la columna de precios de cierre para META ({interval}): ").strip()

    # Extraer precios de cierre
    try:
        tsla_close = tsla_df[tsla_close_column]
    except KeyError:
        print(f"Error: La columna '{tsla_close_column}' no está en TSLA. Columnas disponibles: {list(tsla_df.columns)}")
        continue
    try:
        aapl_close = aapl_df[aapl_close_column]
    except KeyError:
        print(f"Error: La columna '{aapl_close_column}' no está en AAPL. Columnas disponibles: {list(aapl_df.columns)}")
        continue
    try:
        meta_close = meta_df[meta_close_column]
    except KeyError:
        print(f"Error: La columna '{meta_close_column}' no está en META. Columnas disponibles: {list(meta_df.columns)}")
        continue

    # Verificar que los datos sean numéricos y eliminar NaN
    for name, series, col_name in [('TSLA', tsla_close, tsla_close_column),
                                  ('AAPL', aapl_close, aapl_close_column),
                                  ('META', meta_close, meta_close_column)]:
        if not pd.api.types.is_numeric_dtype(series):
            print(f"Error: La columna '{col_name}' en {name} tiene datos no numéricos")
            continue
        if series.isna().all():
            print(f"Error: La columna '{col_name}' en {name} contiene solo valores NaN")
            continue

    # Asegurar que todas las series tengan la misma longitud
    min_length = min(len(tsla_close.dropna()), len(aapl_close.dropna()), len(meta_close.dropna()))
    tsla_close = tsla_close[:min_length]
    aapl_close = aapl_close[:min_length]
    meta_close = meta_close[:min_length]

    if len(tsla_close) == 0 or len(aapl_close) == 0 or len(meta_close) == 0:
        print("Error: No hay datos válidos después de procesar las series")
        continue

    # Realizar pruebas de estacionariedad
    tsla_stationary = unit_root_tests(tsla_close, f"TSLA ({interval})")
    aapl_stationary = unit_root_tests(aapl_close, f"AAPL ({interval})")
    meta_stationary = unit_root_tests(meta_close, f"META ({interval})")

    # Diferenciar si no es estacionaria
    if not tsla_stationary:
        tsla_close_diff = tsla_close.diff().dropna()
        print(f"TSLA ({interval}) diferenciada para intentar estacionariedad")
        unit_root_tests(tsla_close_diff, f"TSLA Diferenciada ({interval})")
    else:
        tsla_close_diff = tsla_close
    if not aapl_stationary:
        aapl_close_diff = aapl_close.diff().dropna()
        print(f"AAPL ({interval}) diferenciada para intentar estacionariedad")
        unit_root_tests(aapl_close_diff, f"AAPL Diferenciada ({interval})")
    else:
        aapl_close_diff = aapl_close
    if not meta_stationary:
        meta_close_diff = meta_close.diff().dropna()
        print(f"META ({interval}) diferenciada para intentar estacionariedad")
        unit_root_tests(meta_close_diff, f"META Diferenciada ({interval})")
    else:
        meta_close_diff = meta_close

    # Graficar series diferenciadas (como en el código COST/WMT)
    print(f"Generando gráfica de series diferenciadas ({interval})...")
    plt.figure(figsize=(12, 6))
    plt.plot(tsla_close_diff, label=f'TSLA Diferenciada ({interval})')
    plt.plot(aapl_close_diff, label=f'AAPL Diferenciada ({interval})')
    plt.plot(meta_close_diff, label=f'META Diferenciada ({interval})')
    plt.title(f'Series Diferenciadas de TSLA, AAPL y META ({interval})')
    plt.xlabel('Índice de Tiempo')
    plt.ylabel('Diferencia de Precio (USD)')
    plt.legend()
    plt.show()
    print(f"Gráfica de series diferenciadas ({interval}) generada.")

    # Preparar datos para cointegración
    coint_df = pd.DataFrame({
        'TSLA': tsla_close,
        'AAPL': aapl_close,
        'META': meta_close
    }).dropna()
    if coint_df.empty:
        print("Error: No hay datos válidos para la prueba de cointegración")
        continue
    cointegrated = cointegration_test(coint_df, interval)

    # Encontrar y ajustar modelos ARIMA
    tsla_order = find_best_arima(tsla_close_diff, f"TSLA ({interval})")
    aapl_order = find_best_arima(aapl_close_diff, f"AAPL ({interval})")
    meta_order = find_best_arima(meta_close_diff, f"META ({interval})")

    # Ajustar modelos finales
    try:
        tsla_model = ARIMA(tsla_close_diff, order=tsla_order).fit(method='nm')
        aapl_model = ARIMA(aapl_close_diff, order=aapl_order).fit(method='nm')
        meta_model = ARIMA(meta_close_diff, order=meta_order).fit(method='nm')
    except Exception as e:
        print(f"Error al ajustar modelos ARIMA: {e}")
        continue

    # Pronosticar 30 períodos
    forecast_steps = 30
    tsla_forecast = tsla_model.forecast(steps=forecast_steps)
    aapl_forecast = aapl_model.forecast(steps=forecast_steps)
    meta_forecast = meta_model.forecast(steps=forecast_steps)

    # Crear índice de pronóstico
    last_index = len(tsla_close) - 1
    forecast_index = range(last_index + 1, last_index + 1 + forecast_steps)

    # Graficar series históricas con pronósticos
    print(f"Generando gráfica de series históricas con pronósticos ({interval})...")
    plt.figure(figsize=(14, 7))
    plt.plot(tsla_close, label='TSLA Histórico')
    plt.plot(forecast_index, tsla_forecast, label='TSLA Pronóstico', color='red')
    plt.plot(aapl_close, label='AAPL Histórico')
    plt.plot(forecast_index, aapl_forecast, label='AAPL Pronóstico', color='green')
    plt.plot(meta_close, label='META Histórico')
    plt.plot(forecast_index, meta_forecast, label='META Pronóstico', color='purple')
    plt.title(f'Precios de Cierre de TSLA, AAPL y META con Pronósticos ({interval})')
    plt.xlabel('Índice de Tiempo')
    plt.ylabel('Precio (USD)')
    plt.legend()
    plt.show()
    print(f"Gráfica de series históricas con pronósticos ({interval}) generada.")

    # Generar gráficos detallados de pronósticos
    plot_forecast(tsla_model, tsla_close_diff, "TSLA", interval)
    plot_forecast(aapl_model, aapl_close_diff, "AAPL", interval)
    plot_forecast(meta_model, meta_close_diff, "META", interval)

    # Imprimir valores de pronóstico
    print(f"\nValores de Pronóstico de TSLA ({interval}) (próximos 5 períodos):")
    print(tsla_forecast[:5].round(2))
    print(f"\nValores de Pronóstico de AAPL ({interval}) (próximos 5 períodos):")
    print(aapl_forecast[:5].round(2))
    print(f"\nValores de Pronóstico de META ({interval}) (próximos 5 períodos):")
    print(meta_forecast[:5].round(2))