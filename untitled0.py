# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10YkhMbBf_MofKMKOMAYQOA1DjT_cpqrr
"""

import pandas as pd
import numpy as np
from google.colab import files
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, kpss
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.vector_ar.vecm import coint_johansen
import json

# Función para pruebas de estacionariedad
def unit_root_tests(series, name):
    print(f"\nPruebas para {name}:")
    adf_result = adfuller(series.dropna())
    print("ADF Test:")
    print(f'Estadístico: {adf_result[0]:.4f}')
    print(f'p-valor: {adf_result[1]:.4f}')
    print("Interpretación:")
    if adf_result[1] < 0.05:
        print(f"  - p-valor < 0.05: {name} es estacionaria")
    else:
        print(f"  - p-valor >= 0.05: {name} puede ser no estacionaria")
    kpss_result = kpss(series.dropna(), regression='c')
    print("\nKPSS Test:")
    print(f'Estadístico: {kpss_result[0]:.4f}')
    print(f'p-valor: {kpss_result[1]:.4f}')
    print("Interpretación:")
    if kpss_result[1] < 0.05:
        print(f"  - p-valor < 0.05: {name} es no estacionaria")
    else:
        print(f"  - p-valor >= 0.05: {name} puede ser estacionaria")

# Función para prueba de cointegración
def cointegration_test(df, interval):
    result = coint_johansen(df.dropna(), det_order=0, k_ar_diff=1)
    print(f"\nPrueba de Cointegración (Johansen) ({interval}):")
    print(f"Estadístico de traza: {result.lr1}")
    print(f"Valores críticos (90%, 95%, 99%): {result.cvt}")
    for i in range(len(result.lr1)):
        if result.lr1[i] > result.cvt[i, 1]:
            print(f"  - r = {i}: Hay cointegración al 95%")
        else:
            print(f"  - r = {i}: No hay cointegración al 95%")
    if result.lr1[0] > result.cvt[0, 1]:
        print("Conclusión: TSLA, AAPL y META están cointegradas")
    else:
        print("Conclusión: No hay evidencia de cointegración")

# Función para encontrar el mejor modelo ARIMA
def find_best_arima(series, name, max_p=3, max_d=2, max_q=3):
    best_aic = float('inf')
    best_order = None
    for p in range(max_p + 1):
        for d in range(max_d + 1):
            for q in range(max_q + 1):
                try:
                    model = ARIMA(series.dropna(), order=(p, d, q))
                    results = model.fit()
                    if results.aic < best_aic:
                        best_aic = results.aic
                        best_order = (p, d, q)
                except:
                    continue
    print(f"\nMejor modelo ARIMA para {name}:")
    print(f"Orden: {best_order}")
    print(f"AIC: {best_aic:.2f}")
    return best_order

# Procesar datos para 1min y 3min
intervals = ['1min', '3min']
for interval in intervals:
    print(f"\n=== Procesando datos de {interval} ===")

    # Subir archivos Excel
    print(f"Sube el archivo TSLA_{interval}.xlsx")
    tsla_upload = files.upload()
    tsla_filename = list(tsla_upload.keys())[0]
    tsla_df = pd.read_excel(tsla_filename)

    print(f"Sube el archivo AAPL_{interval}.xlsx")
    aapl_upload = files.upload()
    aapl_filename = list(aapl_upload.keys())[0]
    aapl_df = pd.read_excel(aapl_filename)

    print(f"Sube el archivo META_{interval}.xlsx")
    meta_upload = files.upload()
    meta_filename = list(meta_upload.keys())[0]
    meta_df = pd.read_excel(meta_filename)

    # Mostrar columnas y primeras filas
    print("\nColumnas de TSLA:", list(tsla_df.columns))
    print("Primeras 5 filas de TSLA:")
    print(tsla_df.head())
    print("\nColumnas de AAPL:", list(aapl_df.columns))
    print("Primeras 5 filas de AAPL:")
    print(aapl_df.head())
    print("\nColumnas de META:", list(meta_df.columns))
    print("Primeras 5 filas de META:")
    print(meta_df.head())

    # Preguntar por los nombres de las columnas
    tsla_close_column = input(f"Ingresa el nombre de la columna de precios de cierre para TSLA ({interval}): ")
    aapl_close_column = input(f"Ingresa el nombre de la columna de precios de cierre para AAPL ({interval}): ")
    meta_close_column = input(f"Ingresa el nombre de la columna de precios de cierre para META ({interval}): ")

    # Extraer precios de cierre
    try:
        tsla_close = tsla_df[tsla_close_column]
    except KeyError:
        print(f"Error: La columna '{tsla_close_column}' no está en TSLA. Columnas disponibles: {list(tsla_df.columns)}")
        raise
    try:
        aapl_close = aapl_df[aapl_close_column]
    except KeyError:
        print(f"Error: La columna '{aapl_close_column}' no está en AAPL. Columnas disponibles: {list(aapl_df.columns)}")
        raise
    try:
        meta_close = meta_df[meta_close_column]
    except KeyError:
        print(f"Error: La columna '{meta_close_column}' no está en META. Columnas disponibles: {list(meta_df.columns)}")
        raise

    # Verificar que los datos sean numéricos y eliminar NaN
    for name, series, col_name in [('TSLA', tsla_close, tsla_close_column), ('AAPL', aapl_close, aapl_close_column), ('META', meta_close, meta_close_column)]:
        if not pd.api.types.is_numeric_dtype(series):
            print(f"Error: La columna '{col_name}' en {name} tiene datos no numéricos")
            raise ValueError("Datos no numéricos detectados")
        if series.isna().all():
            print(f"Error: La columna '{col_name}' en {name} contiene solo valores NaN")
            raise ValueError("Todos los valores son NaN")

    # Asegurar que todas las series tengan la misma longitud
    min_length = min(len(tsla_close.dropna()), len(aapl_close.dropna()), len(meta_close.dropna()))
    tsla_close = tsla_close.dropna()[:min_length]
    aapl_close = aapl_close.dropna()[:min_length]
    meta_close = meta_close.dropna()[:min_length]

    # Realizar pruebas de estacionariedad
    unit_root_tests(tsla_close, f"TSLA ({interval})")
    unit_root_tests(aapl_close, f"AAPL ({interval})")
    unit_root_tests(meta_close, f"META ({interval})")

    # Preparar datos para cointegración
    coint_df = pd.DataFrame({
        'TSLA': tsla_close,
        'AAPL': aapl_close,
        'META': meta_close
    }).dropna()
    if coint_df.empty:
        print("Error: No hay datos válidos después de eliminar NaN para la prueba de cointegración")
        continue
    cointegration_test(coint_df, interval)

    # Encontrar y ajustar modelos ARIMA
    tsla_order = find_best_arima(tsla_close, f"TSLA ({interval})")
    aapl_order = find_best_arima(aapl_close, f"AAPL ({interval})")
    meta_order = find_best_arima(meta_close, f"META ({interval})")

    # Ajustar modelos finales
    tsla_model = ARIMA(tsla_close, order=tsla_order).fit()
    aapl_model = ARIMA(aapl_close, order=aapl_order).fit()
    meta_model = ARIMA(meta_close, order=meta_order).fit()

    # Pronosticar 30 períodos
    forecast_steps = 30
    tsla_forecast = tsla_model.forecast(steps=forecast_steps)
    aapl_forecast = aapl_model.forecast(steps=forecast_steps)
    meta_forecast = meta_model.forecast(steps=forecast_steps)

    # Generar gráfico Chart.js
    historical_data = {
        'labels': list(range(len(tsla_close) + forecast_steps)),
        'datasets': [
            {'label': f'TSLA Historical ({interval})', 'data': tsla_close.tolist() + [None] * forecast_steps, 'borderColor': '#FF6384', 'fill': False},
            {'label': f'TSLA Forecast ({interval})', 'data': [None] * len(tsla_close) + tsla_forecast.tolist(), 'borderColor': '#FF6384', 'borderDash': [5, 5], 'fill': False},
            {'label': f'AAPL Historical ({interval})', 'data': aapl_close.tolist() + [None] * forecast_steps, 'borderColor': '#36A2EB', 'fill': False},
            {'label': f'AAPL Forecast ({interval})', 'data': [None] * len(aapl_close) + aapl_forecast.tolist(), 'borderColor': '#36A2EB', 'borderDash': [5, 5], 'fill': False},
            {'label': f'META Historical ({interval})', 'data': meta_close.tolist() + [None] * forecast_steps, 'borderColor': '#4BC0C0', 'fill': False},
            {'label': f'META Forecast ({interval})', 'data': [None] * len(meta_close) + meta_forecast.tolist(), 'borderColor': '#4BC0C0', 'borderDash': [5, 5], 'fill': False}
        ]
    }

    print(f"\nGráfico de Precios Históricos y Pronosticados ({interval}):")
    print("```chartjs")
    print(json.dumps({
        'type': 'line',
        'data': historical_data,
        'options': {
            'responsive': True,
            'plugins': {'title': {'display': True, 'text': f'TSLA, AAPL, y META Precios de Cierre con Pronósticos ({interval})'}, 'legend': {'position': 'top'}},
            'scales': {'x': {'title': {'display': True, 'text': 'Índice de Tiempo'}}, 'y': {'title': {'display': True, 'text': 'Precio (USD)'}}}
        }
    }, indent=2))
    print("```")

    # Imprimir valores de pronóstico
    print(f"\nPronósticos TSLA ({interval}) (primeros 5 períodos):")
    print(tsla_forecast[:5].round(2))
    print(f"\nPronósticos AAPL ({interval}) (primeros 5 períodos):")
    print(aapl_forecast[:5].round(2))
    print(f"\nPronósticos META ({interval}) (primeros 5 períodos):")
    print(meta_forecast[:5].round(2))

import pandas as pd
import numpy as np
from google.colab import files
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, kpss
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.vector_ar.vecm import coint_johansen
import json

# Función para pruebas de estacionariedad
def unit_root_tests(series, name):
    series = series.dropna()
    if len(series) == 0:
        print(f"Error: No hay datos válidos para {name} después de eliminar NaN")
        return
    print(f"\nPruebas para {name}:")
    adf_result = adfuller(series)
    print("ADF Test:")
    print(f'Estadístico: {adf_result[0]:.4f}')
    print(f'p-valor: {adf_result[1]:.4f}')
    print("Interpretación:")
    if adf_result[1] < 0.05:
        print(f"  - p-valor < 0.05: {name} es estacionaria")
    else:
        print(f"  - p-valor >= 0.05: {name} puede ser no estacionaria")
    kpss_result = kpss(series, regression='c')
    print("\nKPSS Test:")
    print(f'Estadístico: {kpss_result[0]:.4f}')
    print(f'p-valor: {kpss_result[1]:.4f}')
    print("Interpretación:")
    if kpss_result[1] < 0.05:
        print(f"  - p-valor < 0.05: {name} es no estacionaria")
    else:
        print(f"  - p-valor >= 0.05: {name} puede ser estacionaria")

# Función para prueba de cointegración
def cointegration_test(df, interval):
    df = df.dropna()
    if df.empty:
        print(f"Error: No hay datos válidos para la prueba de cointegración ({interval})")
        return
    result = coint_johansen(df, det_order=0, k_ar_diff=1)
    print(f"\nPrueba de Cointegración (Johansen) ({interval}):")
    print(f"Estadístico de traza: {result.lr1}")
    print(f"Valores críticos (90%, 95%, 99%): {result.cvt}")
    for i in range(len(result.lr1)):
        if result.lr1[i] > result.cvt[i, 1]:
            print(f"  - r = {i}: Hay cointegración al 95%")
        else:
            print(f"  - r = {i}: No hay cointegración al 95%")
    if result.lr1[0] > result.cvt[0, 1]:
        print("Conclusión: TSLA, AAPL y META están cointegradas")
    else:
        print("Conclusión: No hay evidencia de cointegración")

# Función para encontrar el mejor modelo ARIMA
def find_best_arima(series, name, max_p=3, max_d=2, max_q=3):
    series = series.dropna()
    if len(series) == 0:
        print(f"Error: No hay datos válidos para {name} para el modelo ARIMA")
        return (0, 0, 0)
    best_aic = float('inf')
    best_order = None
    for p in range(max_p + 1):
        for d in range(max_d + 1):
            for q in range(max_q + 1):
                try:
                    model = ARIMA(series, order=(p, d, q))
                    results = model.fit()
                    if results.aic < best_aic:
                        best_aic = results.aic
                        best_order = (p, d, q)
                except:
                    continue
    print(f"\nMejor modelo ARIMA para {name}:")
    print(f"Orden: {best_order}")
    print(f"AIC: {best_aic:.2f}")
    return best_order if best_order else (0, 0, 0)

# Procesar datos para 1min y 3min
intervals = ['1min', '3min']
for interval in intervals:
    print(f"\n=== Procesando datos de {interval} ===")

    # Subir archivos Excel
    print(f"Sube el archivo TSLA_{interval}.xlsx")
    tsla_upload = files.upload()
    tsla_filename = list(tsla_upload.keys())[0]
    tsla_df = pd.read_excel(tsla_filename)

    print(f"Sube el archivo AAPL_{interval}.xlsx")
    aapl_upload = files.upload()
    aapl_filename = list(aapl_upload.keys())[0]
    aapl_df = pd.read_excel(aapl_filename)

    print(f"Sube el archivo META_{interval}.xlsx")
    meta_upload = files.upload()
    meta_filename = list(meta_upload.keys())[0]
    meta_df = pd.read_excel(meta_filename)

    # Mostrar columnas y primeras filas
    print("\nColumnas de TSLA:", list(tsla_df.columns))
    print("Primeras 5 filas de TSLA:")
    print(tsla_df.head())
    print("\nColumnas de AAPL:", list(aapl_df.columns))
    print("Primeras 5 filas de AAPL:")
    print(aapl_df.head())
    print("\nColumnas de META:", list(meta_df.columns))
    print("Primeras 5 filas de META:")
    print(meta_df.head())

    # Preguntar por los nombres de las columnas
    print(f"Columnas disponibles para TSLA ({interval}): {list(tsla_df.columns)}")
    tsla_close_column = input(f"Ingresa el nombre de la columna de precios de cierre para TSLA ({interval}): ")
    print(f"Columnas disponibles para AAPL ({interval}): {list(aapl_df.columns)}")
    aapl_close_column = input(f"Ingresa el nombre de la columna de precios de cierre para AAPL ({interval}): ")
    print(f"Columnas disponibles para META ({interval}): {list(meta_df.columns)}")
    meta_close_column = input(f"Ingresa el nombre de la columna de precios de cierre para META ({interval}): ")

    # Extraer precios de cierre
    try:
        tsla_close = tsla_df[tsla_close_column]
    except KeyError:
        print(f"Error: La columna '{tsla_close_column}' no está en TSLA. Columnas disponibles: {list(tsla_df.columns)}")
        continue
    try:
        aapl_close = aapl_df[aapl_close_column]
    except KeyError:
        print(f"Error: La columna '{aapl_close_column}' no está en AAPL. Columnas disponibles: {list(aapl_df.columns)}")
        continue
    try:
        meta_close = meta_df[meta_close_column]
    except KeyError:
        print(f"Error: La columna '{meta_close_column}' no está en META. Columnas disponibles: {list(meta_df.columns)}")
        continue

    # Verificar que los datos sean numéricos y eliminar NaN
    for name, series, col_name in [('TSLA', tsla_close, tsla_close_column), ('AAPL', aapl_close, aapl_close_column), ('META', meta_close, meta_close_column)]:
        if not pd.api.types.is_numeric_dtype(series):
            print(f"Error: La columna '{col_name}' en {name} tiene datos no numéricos")
            continue
        if series.isna().all():
            print(f"Error: La columna '{col_name}' en {name} contiene solo valores NaN")
            continue

    # Asegurar que todas las series tengan la misma longitud
    min_length = min(len(tsla_close.dropna()), len(aapl_close.dropna()), len(meta_close.dropna()))
    tsla_close = tsla_close.dropna()[:min_length]
    aapl_close = aapl_close.dropna()[:min_length]
    meta_close = meta_close.dropna()[:min_length]

    if len(tsla_close) == 0 or len(aapl_close) == 0 or len(meta_close) == 0:
        print("Error: No hay datos válidos después de procesar las series")
        continue

    # Realizar pruebas de estacionariedad
    unit_root_tests(tsla_close, f"TSLA ({interval})")
    unit_root_tests(aapl_close, f"AAPL ({interval})")
    unit_root_tests(meta_close, f"META ({interval})")

    # Preparar datos para cointegración
    coint_df = pd.DataFrame({
        'TSLA': tsla_close,
        'AAPL': aapl_close,
        'META': meta_close
    }).dropna()
    if coint_df.empty:
        print("Error: No hay datos válidos después de eliminar NaN para la prueba de cointegración")
        continue
    cointegration_test(coint_df, interval)

    # Encontrar y ajustar modelos ARIMA
    tsla_order = find_best_arima(tsla_close, f"TSLA ({interval})")
    aapl_order = find_best_arima(aapl_close, f"AAPL ({interval})")
    meta_order = find_best_arima(meta_close, f"META ({interval})")

    # Ajustar modelos finales
    tsla_model = ARIMA(tsla_close, order=tsla_order).fit()
    aapl_model = ARIMA(aapl_close, order=aapl_order).fit()
    meta_model = ARIMA(meta_close, order=meta_order).fit()

    # Pronosticar 30 períodos
    forecast_steps = 30
    tsla_forecast = tsla_model.forecast(steps=forecast_steps)
    aapl_forecast = aapl_model.forecast(steps=forecast_steps)
    meta_forecast = meta_model.forecast(steps=forecast_steps)

    # Generar gráfico Chart.js
    historical_data = {
        'labels': list(range(len(tsla_close) + forecast_steps)),
        'datasets': [
            {'label': f'TSLA Historical ({interval})', 'data': tsla_close.tolist() + [None] * forecast_steps, 'borderColor': '#FF6384', 'fill': False},
            {'label': f'TSLA Forecast ({interval})', 'data': [None] * len(tsla_close) + tsla_forecast.tolist(), 'borderColor': '#FF6384', 'borderDash': [5, 5], 'fill': False},
            {'label': f'AAPL Historical ({interval})', 'data': aapl_close.tolist() + [None] * forecast_steps, 'borderColor': '#36A2EB', 'fill': False},
            {'label': f'AAPL Forecast ({interval})', 'data': [None] * len(aapl_close) + aapl_forecast.tolist(), 'borderColor': '#36A2EB', 'borderDash': [5, 5], 'fill': False},
            {'label': f'META Historical ({interval})', 'data': meta_close.tolist() + [None] * forecast_steps, 'borderColor': '#4BC0C0', 'fill': False},
            {'label': f'META Forecast ({interval})', 'data': [None] * len(meta_close) + meta_forecast.tolist(), 'borderColor': '#4BC0C0', 'borderDash': [5, 5], 'fill': False}
        ]
    }

    print(f"\nGráfico de Precios Históricos y Pronosticados ({interval}):")
    print("```chartjs")
    print(json.dumps({
        'type': 'line',
        'data': historical_data,
        'options': {
            'responsive': True,
            'plugins': {'title': {'display': True, 'text': f'TSLA, AAPL, y META Precios de Cierre con Pronósticos ({interval})'}, 'legend': {'position': 'top'}},
            'scales': {'x': {'title': {'display': True, 'text': 'Índice de Tiempo'}}, 'y': {'title': {'display': True, 'text': 'Precio (USD)'}}}
        }
    }, indent=2))
    print("```")

    # Imprimir valores de pronóstico
    print(f"\nPronósticos TSLA ({interval}) (primeros 5 períodos):")
    print(tsla_forecast[:5].round(2))
    print(f"\nPronósticos AAPL ({interval}) (primeros 5 períodos):")
    print(aapl_forecast[:5].round(2))
    print(f"\nPronósticos META ({interval}) (primeros 5 períodos):")
    print(meta_forecast[:5].round(2))